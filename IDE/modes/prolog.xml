<?xml version="1.0"?>

<!--
 GOAL interpreter that facilitates developing and executing GOAL multi-agent
 programs. Copyright (C) 2011 K.V. Hindriks, W. Pasman
 
 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
 Foundation, either version 3 of the License, or (at your option) any later
 version.
 
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 details.
 
 You should have received a copy of the GNU General Public License along with
 this program. If not, see <http://www.gnu.org/licenses/>.
 -->

<!--	jEdit  GOAL-PROLOG syntax file
 	author W.Pasman@tudelft.nl
	modified W.Pasman 16+17 november 2008
-->
 
<!DOCTYPE MODE SYSTEM "xmode.dtd">


<MODE>
	<PROPS>
		<PROPERTY NAME="lineComment" VALUE="%" />
		<PROPERTY NAME="commentStart" VALUE="/*" />
		<PROPERTY NAME="commentEnd" VALUE="*/" />
 	
		<!-- indent clauses not ending on a dot on this line, and un-indent those ending on dot.
			We exclude comment lines from this (un)indentation scheme 
			additionally, unindentThisLine un-indents the CURRENT line (but not the one after that).
			it only works if you set electricKeys to trigger the un-indent at the right moment.
			NOT at all in documentation: unindentNextLines (note the S).
			
			WORKAROUND: Due to what seems to me a bug in jEdit, we copy the GOAL indentation rules for curly brackets.
			Without that, the GOAL level curly settings will also change, disturbing the auto-indentation process there.
			This causes slight misbehaviour in the Prolog when you work with curlies, but those are not very common anyway.
		-->

		<PROPERTY NAME="unalignedOpenBrackets" VALUE="#" />
		<PROPERTY NAME="unalignedCloseBrackets" VALUE="#" />
		<PROPERTY NAME="indentOpenBrackets" VALUE="{" />
		<PROPERTY NAME="indentCloseBrackets" VALUE="}" />

		<!-- Auto indentation support for head of clause including the :-
		If your contains :- and does not end on . we auto-indent the next line.
		KNOWN BUG: if you use the dot inside a rule but not as a closing dot eg decimal punt,
		the following will go wrong. -->
		<PROPERTY NAME="indentNextLines" VALUE="(?!.*:-.*\.\s*).*:-.*" />
		<!-- un-indent is tricky, luckily possible comments are already filtered out by jEdit
		but the real problem is that we CAN NOT KNOW whether we did an auto-indent,
		because the rule containing the :- may be way up in the file.
		So it is not clear what to do when we encounter e.g. "beer(X)." Was that rule following e.g. "aap(X):-", 
		or is beer(X) a plain fact? In the first case we might un-indent, in the second rather not.
        <PROPERTY NAME="unindentNextLines" VALUE="^(?!.*:-.*).*\.\s*" />
         -->
	    
	</PROPS>

	<RULES IGNORE_CASE="FALSE">

		<PROPS>
			<PROPERTY NAME="lineComment" VALUE="%" />
		</PROPS>

        <!-- hexadecimal numbers -->
        <SEQ_REGEXP TYPE="DIGIT">0x[0-9a-fA-F]{1,8}</SEQ_REGEXP>
        <!-- octal numbers -->
        <SEQ_REGEXP TYPE="DIGIT">0o[0-7]{1,11}</SEQ_REGEXP>
        <!-- binary numbers -->
        <SEQ_REGEXP TYPE="DIGIT">0b[01]{1,32}</SEQ_REGEXP>
        <!-- floating-point numbers. can have exponentials -->
        <SEQ_REGEXP TYPE="DIGIT">[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?</SEQ_REGEXP>
        <!-- integer numbers. can not have exponentials. -->
        <SEQ_REGEXP TYPE="DIGIT">[0-9]+</SEQ_REGEXP>

		<!-- Comments -->
		<EOL_SPAN TYPE="COMMENT1">%</EOL_SPAN>
		<!--- ISO compliant C-style comments -->
		<SPAN TYPE="COMMENT1">
			<BEGIN>/*</BEGIN>
			<END>*/</END>
		</SPAN>
		
		<SPAN_REGEXP TYPE="KEYWORD2" DELEGATE="STRING">
          <BEGIN>#import(\s)*</BEGIN>
          <END>.</END>
        </SPAN_REGEXP>

		<!-- String literals -->
		<SPAN TYPE="LITERAL1" ESCAPE="\" NO_LINE_BREAK="TRUE">
			<BEGIN>'</BEGIN>
			<END>'</END>
		</SPAN>
		<SPAN TYPE="LITERAL1" ESCAPE="\" NO_LINE_BREAK="TRUE">
			<BEGIN>"</BEGIN>
			<END>"</END>
		</SPAN>


		<!-- Operators. in increasing order of priority. -->
		 <!-- prio 50 -->
		<SEQ TYPE="OPERATOR">:</SEQ>
		 <!-- prio 100 -->
		<SEQ TYPE="OPERATOR">@</SEQ>
		 <!-- prio 200... -->
		<SEQ TYPE="OPERATOR">-</SEQ>
		<SEQ TYPE="OPERATOR">\</SEQ>
		<SEQ TYPE="OPERATOR">**</SEQ>
		<SEQ TYPE="OPERATOR">^</SEQ>
		<!-- prio 400 -->
		<SEQ TYPE="OPERATOR">*</SEQ> 
		<SEQ TYPE="OPERATOR">/</SEQ>
		<SEQ TYPE="OPERATOR">//</SEQ> 
				<!-- rem and mod are treated as keywords -->
		<SEQ TYPE="OPERATOR">&lt;&lt;</SEQ>
		<SEQ TYPE="OPERATOR">&gt;&gt;</SEQ>
		<SEQ TYPE="OPERATOR">+</SEQ>
		
		 <!-- prio 500 -->
				<!-- '-' is also infix 500 but we already have prefix 200 
					and that one will catch it anyway in this simple parser -->
		<SEQ TYPE="OPERATOR">/\</SEQ>
		<SEQ TYPE="OPERATOR">\/</SEQ>
		 <!-- prio 500 SWI prolog only -->
		<SEQ TYPE="OPERATOR">xor</SEQ>
		
		 <!-- prio 700 -->
		<SEQ TYPE="OPERATOR">=:=</SEQ>
				<!-- is is treated as keyword, just like rem and mod above.  -->
		<SEQ TYPE="OPERATOR">=\=</SEQ>
		<SEQ TYPE="OPERATOR">&lt;</SEQ>
		<SEQ TYPE="OPERATOR">=&lt;</SEQ>
		<SEQ TYPE="OPERATOR">&gt;</SEQ>
		<SEQ TYPE="OPERATOR">&gt;=</SEQ>
		<SEQ TYPE="OPERATOR">=..</SEQ>
		<SEQ TYPE="OPERATOR">==</SEQ>
		<SEQ TYPE="OPERATOR">\==</SEQ>
		<SEQ TYPE="OPERATOR">@&lt;</SEQ>
		<SEQ TYPE="OPERATOR">=@=</SEQ>
		<SEQ TYPE="OPERATOR">@=&lt;</SEQ>
		<SEQ TYPE="OPERATOR">@&gt;</SEQ>
		<SEQ TYPE="OPERATOR">@&gt;=</SEQ>
		<SEQ TYPE="OPERATOR">=</SEQ>
		<SEQ TYPE="OPERATOR">\=</SEQ>
		 <!-- prio 900, only for SWI prolog ? -->
		<SEQ TYPE="OPERATOR">\+</SEQ>
		
		 <!-- prio 1000 -->
		<SEQ TYPE="OPERATOR">,</SEQ>

		 <!-- prio 1050 -->
		<SEQ TYPE="OPERATOR">*-&gt;</SEQ>
		<SEQ TYPE="OPERATOR">-&gt;</SEQ>

		 <!-- prio 1100 -->
		<SEQ TYPE="OPERATOR">;</SEQ>
		<!-- prio 1105 -->
		<SEQ TYPE="OPERATOR">|</SEQ>
		
		 <!-- prio 1200. :- and . are handled separately with a SPAN -->
		<SEQ TYPE="OPERATOR">:-</SEQ>
		<SEQ TYPE="OPERATOR">?-</SEQ>
		<SEQ TYPE="OPERATOR">--&gt;</SEQ>
		
		
		<!-- prio "1250" (actually it's not an operator but OK.) -->
			<!-- The '.' at the end of each clause -->
		<SEQ TYPE="OPERATOR">.</SEQ>
	
		
		
		<!--SPAN TYPE="KEYWORD2" DELEGATE="MAIN">
			<BEGIN>(</BEGIN>
			<END>)</END>	
		</SPAN-->
		<SPAN TYPE="KEYWORD2" DELEGATE="MAIN">
			<BEGIN>{</BEGIN>
			<END>}</END>	
		</SPAN>
		
		<SPAN TYPE="LITERAL2" DELEGATE="MAIN">
			<BEGIN>\[</BEGIN>
			<END>\]</END>	
		</SPAN>

					
			<!-- TODO write down WHY SEQ is used instead of keywords.... -->
		<!-- Keywords that should be operators 
			They are here CHECK because if they would be SEQ type they would be 
			recognised also when PART OF a string which is not the idea. -->
			<!-- TODO problem with SEQ is that it triggers also on initial part of longer keywords.
			So if you have "eButton" in your text, the initial "e" will be highlighted as FUNCTION -->
		<SEQ TYPE="FUNCTION">is</SEQ>
		<SEQ TYPE="FUNCTION">rem</SEQ>
		<SEQ TYPE="FUNCTION">rdiv</SEQ>
		<SEQ TYPE="FUNCTION">mod</SEQ>
		
		<SEQ TYPE="FUNCTION">true</SEQ>
		<SEQ TYPE="FUNCTION">false</SEQ>
		<SEQ TYPE="FUNCTION">fail</SEQ>
		<SEQ TYPE="FUNCTION">input</SEQ>
		<SEQ TYPE="FUNCTION">output</SEQ>
		<SEQ TYPE="FUNCTION">flush_output</SEQ>
		<SEQ TYPE="FUNCTION">ttyflush</SEQ>
		<SEQ TYPE="FUNCTION">at_end_of_stream</SEQ>
		<SEQ TYPE="FUNCTION">alnum</SEQ>
		<SEQ TYPE="FUNCTION">alpha</SEQ>
		<SEQ TYPE="FUNCTION">csym</SEQ>
		<SEQ TYPE="FUNCTION">csymf</SEQ>
		<SEQ TYPE="FUNCTION">ascii</SEQ>
		<SEQ TYPE="FUNCTION">white</SEQ>
		<SEQ TYPE="FUNCTION">cntrl</SEQ>
		<SEQ TYPE="FUNCTION">digit</SEQ>
		<SEQ TYPE="FUNCTION">graph</SEQ>
		<SEQ TYPE="FUNCTION">upper</SEQ>
		<SEQ TYPE="FUNCTION">lower</SEQ>
		<SEQ TYPE="FUNCTION">punct</SEQ>
		<SEQ TYPE="FUNCTION">space</SEQ>
		<SEQ TYPE="FUNCTION">end_of_file</SEQ>
		<SEQ TYPE="FUNCTION">end_of_line</SEQ>
		<SEQ TYPE="FUNCTION">newline</SEQ>
		<SEQ TYPE="FUNCTION">period</SEQ>
		<SEQ TYPE="FUNCTION">quote</SEQ>
		<SEQ TYPE="FUNCTION">epsilon</SEQ>
		<SEQ TYPE="FUNCTION">cputime</SEQ>
		<SEQ TYPE="FUNCTION">read</SEQ>
		<SEQ TYPE="FUNCTION">write</SEQ>
		<SEQ TYPE="FUNCTION">append</SEQ>
		<SEQ TYPE="FUNCTION">exist</SEQ>
		<SEQ TYPE="FUNCTION">none</SEQ>
		<SEQ TYPE="FUNCTION">txt</SEQ>
		<SEQ TYPE="FUNCTION">prolog</SEQ>
		<SEQ TYPE="FUNCTION">executable</SEQ>
		<SEQ TYPE="FUNCTION">qlf</SEQ>
		<SEQ TYPE="FUNCTION">directory</SEQ>
		<SEQ TYPE="FUNCTION">source</SEQ>
		<SEQ TYPE="FUNCTION">error</SEQ>
		<SEQ TYPE="FUNCTION">fail</SEQ>
		<SEQ TYPE="FUNCTION">first</SEQ>
		<SEQ TYPE="FUNCTION">verbose_file_search</SEQ>
		<!-- keep short ones to the end, they might be start of longer keywords.. -->
		<SEQ TYPE="FUNCTION">pi</SEQ>
		<SEQ TYPE="FUNCTION">nl</SEQ>
		<SEQ TYPE="FUNCTION">e</SEQ>
		<SEQ TYPE="FUNCTION">!</SEQ>
		
		
		
		
		<!-- Keywords that are built-in predicates with arity greater than or equal to 1 -->
		<!-- this is adapted manual copy of GOALProgram.prologBuiltin.
			It would be nice if this could be somehow generated... -->
		<!-- order same as in kr.language.prolog.PrologOperators.java -->
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>not\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>is_list\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>is_set\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>list_to_set\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>length\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>last\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>sort\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>merge\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>delete\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>maplist\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>maplist\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>maplist\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>maplist\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>sublist\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>include\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>reverse\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>flatten\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>member\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>append\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>prefix\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>intersection\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>nth0\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>nth1\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>max_list\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>min_list\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>nextto\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>numlist\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>permutation\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>proper_length\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>select\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>selectchk\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>subset\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>subtract\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>sumlist\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>union\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>exclude\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>partition\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>random\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>random_between\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>random_member\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>random_perm\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>random_permutation\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>random_select\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>randseq\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>randset\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>setrand\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>setof\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>bagof\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>findall\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>aggregate\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>aggregate\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>aggregate_all\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>aggregate_all\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>same_length\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>select\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>selectchk\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>forall\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>max\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>min\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>count\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>sum\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>set\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>bag\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>time\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get_time\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>convert_time\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>date\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>date/9\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>date_time_stamp\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>day_of_the_week\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>stamp_date_time\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>var\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>nonvar\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>integer\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>float\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>rational\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>rational\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>number\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>atom\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>string\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>atomic\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>compound\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ground\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>cyclic_term\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>acyclic_term\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>compare\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>unify_with_occurs_check\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>call\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>call\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>call\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>call\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>call\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>call\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>once\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ignore\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>call_with_depth_limit\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>setup_call_cleanup\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>setup_call_catcher_cleanup\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>call_cleanup\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>call_cleanup\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>print_message\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>print_message_lines\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>message_to_string\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>phrase\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>phrase\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_empty\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_seteq\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>list_to_ord_set\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_intersect\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_disjoint\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_intersection\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_add_element\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_del_element\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_memberchk\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_member\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_subset\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_subtract\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_union\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ord_symdiff\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>open\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>alias\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>encoding\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>bom\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>eof_action\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>buffer\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>close_on_abort\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>lock\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>open\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>open_null_stream\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>close\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>close\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>stream_property\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>end_of_stream\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>eof_action\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>file_name\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>file_no\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>mode\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>newline\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>nlink\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>position\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>reposition\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>representation_errors\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>timeout\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>type\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>tty\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>current_stream\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>is_stream\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>set_stream_position\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>stream_position_data\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>seek\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>set_stream\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>set_prolog_IO\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>with_output_to\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>wait_for_input\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>byte_count\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>character_count\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>line_count\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>line_position\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>nl\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>put\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>put\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>put_byte\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>put_byte\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>put_char\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>put_char\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>put_code\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>put_code\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>tab\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>tab\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>flush_output\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get_byte\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get_byte\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get_code\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get_code\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get_char\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get_char\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get0\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get0\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>peek_byte\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>peek_byte\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>peek_code\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>peek_code\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>peek_char\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>peek_char\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>skip\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>skip\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>get_single_char\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>at_end_of_stream\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>copy_stream_data\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>copy_stream_data\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>read_pending_input\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>write_term\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>attributes\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>backquoted_string\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>character_escapes\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ignore_ops\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>max_depth\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>module\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>numbervars\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>partial\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>portray\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>priority\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>quoted\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>write_term\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>write_canonical\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>write_canonical\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>write\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>write\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>writeq\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>writeq\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>print\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>print\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>read\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>read\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>read_clause\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>read_clause\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>read_term\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>comments\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>double_quotes\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>singletons\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>syntax_errors\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>subterm_positions\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>string_position\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>brace_term_position\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>list_position\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>term_position\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>term_position\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>variables\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>variable_names\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>read_term\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>read_history\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>prompt\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>prompt1\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>atom_codes\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>atom_chars\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>char_code\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>number_chars\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>number_codes\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>name\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>atom_concat\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>char_type\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>digit\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>xdigit\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>lower\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>to_lower\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>upper\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>to_upper\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>paren\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>code_type\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>downcase_atom\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>upcase_atom\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>normalize_space\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>collation_key\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>locale_sort\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>string_to_atom\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>string_to_list\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>string_length\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>string_concat\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>sub_string\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>char_conversion\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>current_char_conversion\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>between\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>sqrt\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>floor\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ceiling\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>truncate\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>round\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>round\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>min\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>max\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>sign\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>abs\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>log\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>log10\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>exp\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>succ\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>plus\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>random\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>integer\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>float\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>rational\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>rationalize\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>float_fractional_part\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>float_integer_part\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>ceil\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>sin\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>cos\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>tan\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>asin\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>acos\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>atan\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>atan\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>powm\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>eval\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>msb\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>lsb\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>popcount\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>set_random\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>seed\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>memberchk\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>msort\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>keysort\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>predsort\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>writeln\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>writef\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>writef\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>swritef\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>swritef\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>format\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>format\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>format\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>format_predicate\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>current_format_predicate\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>date_time_value\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>day_of_week\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>format_time\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>format_time\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>parse_time\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>access_file\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>exists_file\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>file_directory_name\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>file_base_name\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>same_file\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>exists_directory\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>delete_file\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>rename_file\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>size_file\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>time_file\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>absolute_file_name\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>absolute_file_name\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>extensions\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>relative_to\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>access\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>file_type\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>file_errors\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>solutions\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>expand\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>is_absolute_file_name\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>file_name_extension\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>expand_file_name\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>prolog_to_os_filename\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>read_link\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>tmp_file\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>make_directory\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>delete_directory\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>working_directory\s*\(</BEGIN><END>)</END></SPAN_REGEXP>
		<SPAN_REGEXP TYPE="FUNCTION" DELEGATE="MAIN"><BEGIN>chdir\s*\(</BEGIN><END>)</END></SPAN_REGEXP>



        <SPAN TYPE="KEYWORD2" DELEGATE="MAIN"><BEGIN>(</BEGIN><END>)</END></SPAN>
		<SEQ_REGEXP TYPE="KEYWORD3" AT_WORD_START="TRUE">[a-z][a-zA-Z0-9_]*</SEQ_REGEXP>
		<SEQ_REGEXP TYPE="KEYWORD4" AT_WORD_START="TRUE">[A-Z_][a-zA-Z0-9_]*</SEQ_REGEXP>
		
	</RULES>

    <!-- string contents. only used for #import command coloring -->
    <RULES SET="STRING" >
    	<PROPS>
			<PROPERTY NAME="lineComment" VALUE="%" />
		</PROPS>
        <SPAN TYPE="LITERAL2" NO_LINE_BREAK="TRUE">
            <BEGIN>"</BEGIN>
            <END>"</END>
        </SPAN>
        <SPAN TYPE="LITERAL2" NO_LINE_BREAK="TRUE">
            <BEGIN>'</BEGIN>
            <END>'</END>
        </SPAN>
    </RULES>
    <RULES SET="STRING_CONTENT">
       <SEQ_REGEXP TYPE="LITERAL1">[^"]*</SEQ_REGEXP>
    </RULES>
	
	
</MODE>
