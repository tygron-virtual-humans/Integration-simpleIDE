/**
 * GOAL interpreter that facilitates developing and executing GOAL multi-agent
 * programs. Copyright (C) 2011 K.V. Hindriks, W. Pasman
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

package nl.tudelft.goal.SimpleIDE.prefgui;

import goal.preferences.DebugPreferences;
import goal.tools.debugger.Channel;
import goal.tools.debugger.Channel.ChannelState;
import goal.tools.errorhandling.exceptions.GOALBug;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.SwingConstants;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableColumn;

/**
 * Panel that shows the breakpoints that can be set and the type of debug
 * messages that can be shown while running a GOAL MAS.
 *
 * <p>
 * This functionality is needed also in uninstaller Therefore avoid general
 * dependencies on GOAL, e.g. don't use the Logger, don't use callbacks to the
 * SimpleIDE etc
 * </p>
 *
 * @author KH
 * @modified W.Pasman 13feb2012 do not use any GOAL classes here, they will not
 *           be included in the uninstaller. Removed the reference to GOALBug.
 * @modified V.Koeman 12jun13 refactoring preferences: management separated from
 *           display through new class
 * @modified W.Pasman 28may2014 fixed cyclic dependency of model on view.
 *           Separated view from model. model directly attached to
 *           {@link DebugPreferences}. Removed channelstate fiddling from the
 *           view.
 */
public class DebugPreferencePane extends JPanel implements TableModelListener {
	/**
	 *
	 */
	private static final long serialVersionUID = -2387796645759964908L;
	/**
	 * This is a list of all channels that the user can edit. We don't use the
	 * full list, see #1497.
	 */
	private final List<Channel> channels = new ArrayList<Channel>();
	/**
	 *
	 */
	private final JTable table;

	/**
	 * Provides a preference panel that allows user to set its preferences for
	 * viewing debug messages and for pausing on specific breakpoints.
	 *
	 * @param parent
	 *            the IDE that owns this panel, needed to handle update events
	 *            related to changes in viewing and pausing preferences.
	 */
	public DebugPreferencePane() {

		super(new GridLayout(1, 0));

		for (Channel channel : Channel.values()) {
			// do not display hidden channels
			if (!DebugPreferences.getChannelState(channel).isHidden()) {
				this.channels.add(channel);
			}
		}

		// Create display.
		this.table = new JTable(new MyTableModel(this.channels));
		this.table.setPreferredScrollableViewportSize(this.table
				.getPreferredScrollableViewportSize());
		this.table.setFillsViewportHeight(true);
		this.table.setCellSelectionEnabled(false);

		// Center headers.
		((DefaultTableCellRenderer) this.table.getTableHeader()
				.getDefaultRenderer())
				.setHorizontalAlignment(SwingConstants.CENTER);

		// Create the scroll pane and add the table to it
		JScrollPane scrollPane = new JScrollPane(this.table);

		// Initialize sizes
		initSize(this.table);

		// Subscribe to listen to events generated by the table model.
		this.table.getModel().addTableModelListener(this);

		// Add the scroll pane to this panel
		add(scrollPane);
	}

	@Override
	public void tableChanged(TableModelEvent arg0) {
	}

	/**
	 * Determines good column sizes and table height.
	 */
	private void initSize(JTable table) {
		MyTableModel model = (MyTableModel) table.getModel();
		TableColumn column = null;
		Component comp = null;

		int tableWidth = 0;
		for (int i = 0; i < 3; i++) {
			column = table.getColumnModel().getColumn(i);

			comp = table.getDefaultRenderer(String.class)
					.getTableCellRendererComponent(table,
							model.getLongValues()[i], false, false, 0, i);

			column.setPreferredWidth(comp.getPreferredSize().width);
			tableWidth += Math.round(comp.getPreferredSize().width * 1.5);
		}

		// adjust height to number of rows in table
		int height = table.getRowCount() * table.getRowHeight()
				+ table.getRowHeight();
		table.setPreferredScrollableViewportSize(new Dimension(tableWidth,
				height));
	}

}

class MyTableModel extends AbstractTableModel {
	/**
	 *
	 */
	private static final long serialVersionUID = -7544734395198540262L;
	private final List<Channel> channels;
	private final String[] columnNames = { "Breakpoint", "View", "Pause" };

	// longValues contains the longest string for each column
	private final String[] longValues = new String[3];

	/**
	 * Loads content of table.
	 */
	public MyTableModel(List<Channel> theChannels) {
		this.channels = theChannels;

		getLongValues()[0] = new String(this.columnNames[0]);
		getLongValues()[1] = new String(this.columnNames[1]);
		getLongValues()[2] = new String(this.columnNames[2]);

		for (int i = 0; i < this.channels.size(); i++) {
			String expl = this.channels.get(i).getExplanation();
			if (expl.length() > getLongValues()[0].length()) {
				getLongValues()[0] = new String(expl);
			}
		}
	}

	@Override
	public int getColumnCount() {
		return this.columnNames.length;
	}

	@Override
	public int getRowCount() {
		return this.channels.size();
	}

	@Override
	public String getColumnName(int col) {
		return this.columnNames[col];
	}

	@Override
	public Object getValueAt(int row, int col) {
		switch (col) {
		case 0:
			return this.channels.get(row).getExplanation();
		case 1:
			return isView(row);
		case 2:
			return isPause(row);
		}
		throw new GOALBug("Debug Preference pane got illegal column " + col);
	}

	/**
	 * Returns class of object in column, enables check boxes for booleans.
	 */
	@Override
	public Class<?> getColumnClass(int c) {
		return getValueAt(0, c).getClass();
	}

	/**
	 * Allows to edit second and third rows.
	 */
	@Override
	public boolean isCellEditable(int row, int col) {
		return (col > 0);
	}

	private Boolean isView(int row) {
		return DebugPreferences.getChannelState(this.channels.get(row))
				.canView();
	}

	private Boolean isPause(int row) {
		return DebugPreferences.getChannelState(this.channels.get(row))
				.shouldPause();
	}

	/**
	 * Allows to edit contents of table. Assumes value!=null
	 *
	 * @param val
	 *            the new value for the item at row-col. Assumed to be Boolean.
	 */
	@Override
	public void setValueAt(Object val, int row, int col) {
		// this may throw ClassCast if thiss is not a Boolean.
		// that would be a bug.
		Boolean value = (Boolean) val;
		switch (col) {
		case 1:
			DebugPreferences.setChannelState(this.channels.get(row),
					computeState(value, isPause(row)));
			break;
		case 2:
			DebugPreferences.setChannelState(this.channels.get(row),
					computeState(isView(row), value));
			break;
		}

		// one change may result in dramatic effect. Particularly the 'all'
		// option. Just refresh it all
		fireTableDataChanged();
	}

	/**
	 * Compute the channel state value from a view and a pause value
	 *
	 * @param view
	 *            Channel.VIEW true or false
	 * @param pause
	 *            Channel.PAUSE true or false
	 */
	private ChannelState computeState(Boolean view, Boolean pause) {
		if (pause) {
			return ChannelState.VIEWPAUSE; // PAUSE also enables VIEW
		}
		return view ? ChannelState.VIEW : ChannelState.NONE;
	}

	/**
	 * @return the longValues. longValues contains the longest string for each
	 *         column. Used for determining the column widths.
	 */
	public String[] getLongValues() {
		return this.longValues;
	}
}
